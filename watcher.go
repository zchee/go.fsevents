package fsevents

/*
#cgo LDFLAGS: -framework CoreServices
#include <CoreServices/CoreServices.h>
FSEventStreamRef fswatch_create(
	FSEventStreamContext*,
	CFMutableArrayRef,
	FSEventStreamEventId,
	CFTimeInterval,
	FSEventStreamCreateFlags);
FSEventStreamRef fswatch_create_relative_to_device(
	dev_t,
	FSEventStreamContext*,
	CFMutableArrayRef,
	FSEventStreamEventId,
	CFTimeInterval,
	FSEventStreamCreateFlags);
static CFMutableArrayRef fswatch_make_mutable_array() {
  return CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
}

*/
import "C"

import (
	"time"

	"unsafe"
)

// CreateFlags for creating a New stream
type CreateFlags uint32

// kFSEventStreamCreateFlag...
const (
	// use CoreFoundation types instead of raw C types (disabled)
	useCFTypes CreateFlags = 1 << iota

	// NoDefer sends events on the leading edge (for interactive applications).
	// By default events are delivered after latency seconds (for background tasks).
	NoDefer

	// WatchRoot for a change to occur to a directory along the path being watched.
	WatchRoot

	// IgnoreSelf doesn't send events triggered by the current process (OS X 10.6+).
	IgnoreSelf

	// FileEvents sends events about individual files, generating significantly
	// more events (OS X 10.7+) than directory level notifications.
	FileEvents

	CreateFlagNone CreateFlags = 0
)

// EventFlags passed to the FSEventStreamCallback function.
type EventFlags uint32

// kFSEventStreamEventFlag...
const (
	// MustScanSubDirs indicates that events were coalesced hierarchically.
	MustScanSubDirs EventFlags = 1 << iota
	// UserDropped or KernelDropped is set alongside MustScanSubDirs
	// to help diagnose the problem.
	UserDropped
	KernelDropped

	// EventIdsWrapped indicates the 64-bit event ID counter wrapped around.
	EventIdsWrapped

	// HistoryDone is a sentinel event when retrieving events sinceWhen.
	HistoryDone

	// RootChanged indicates a change to a directory along the path being watched.
	RootChanged

	// Mount for a volume mounted underneath the path being monitored.
	Mount
	// Unmount event occurs after a volume is unmounted.
	Unmount

	// The following flags are only set when using FileEvents.

	Created
	Removed
	InodeMetaMod
	Renamed
	Modified
	FinderInfoMod
	ChangeOwner
	XattrMod
	IsFile
	IsDir
	IsSymlink

	EventFlagNone EventFlags = 0
)

// EventID are monotonically increasing per system, even across reboots.
type EventID C.FSEventStreamEventId

// SinceNow is a special constant to receive events from now onwards.
// EventID has type UInt64 but this constant is represented as -1
// which is represented by 63 1's in memory (kFSEventStreamEventIdSinceNow)
const SinceNow EventID = (1 << 64) - 1

// SinceAll to receive all events since "the beginning of time".
const SinceAll EventID = 0

// Device UUID representing a Mountpoint in OS X.
// fi, _ := os.Stat("")
// dev := Device(fi.Sys().(*syscall.Stat_t).Dev)
type Device C.dev_t

// Stream for monitoring one or more paths.
type Stream struct {
	Chan    chan []Event
	cstream C.FSEventStreamRef
	runloop C.CFRunLoopRef
}

// Event sent down the stream.
type Event struct {
	ID    EventID
	Path  string
	Flags EventFlags
}

// Current fetches the most recent EventID generated by the system.
func Current() EventID {
	return EventID(C.FSEventsGetCurrentEventId())
}

// LastEventBefore fetches the last event for a given device before the given time.
func LastEventBefore(dev Device, ts time.Time) EventID {
	return EventID(
		C.FSEventsGetLastEventIdForDeviceBeforeTime(
			C.dev_t(dev),
			C.CFAbsoluteTime(ts.Unix())))
}

// TODO: FSEventsPurgeEventsForDeviceUpToEventId

// Paths fetches the paths supplied when the stream was created.
func (s Stream) Paths() []string {
	cpaths := C.FSEventStreamCopyPathsBeingWatched(s.cstream)
	defer C.CFRelease(C.CFTypeRef(cpaths))
	count := C.CFArrayGetCount(cpaths)
	paths := make([]string, count)
	var i C.CFIndex
	for ; i < count; i++ {
		cpath := C.CFStringRef(C.CFArrayGetValueAtIndex(cpaths, i))
		paths[i] = fromCFString(cpath)
	}
	return paths
}

func fromCFString(cstr C.CFStringRef) string {
	defer C.CFRelease(C.CFTypeRef(cstr))

	var (
		buf  []C.char
		ok   C.Boolean
		size uint = 1024
	)
	for ok == C.FALSE {
		buf = make([]C.char, size)
		ok = C.CFStringGetCString(cstr, &buf[0],
			C.CFIndex(len(buf)), C.kCFStringEncodingUTF8)
		size *= 2
	}
	return C.GoString(&buf[0])
}

// New creates a new stream to watch the specified paths.
func New(dev Device, since EventID, interval time.Duration, flags CreateFlags,
	paths ...string) *Stream {

	cpaths := C.fswatch_make_mutable_array()
	defer C.free(unsafe.Pointer(cpaths))
	for _, dir := range paths {
		path := C.CString(dir)
		defer C.free(unsafe.Pointer(path))
		str := C.CFStringCreateWithCString(nil, path, C.kCFStringEncodingUTF8)
		defer C.free(unsafe.Pointer(str))
		C.CFArrayAppendValue(cpaths, unsafe.Pointer(str))
	}

	csince := C.FSEventStreamEventId(since)
	cinterval := C.CFTimeInterval(interval / time.Second)
	cflags := C.FSEventStreamCreateFlags(flags &^ useCFTypes)

	s := new(Stream)
	s.Chan = make(chan []Event)

	ctx := C.FSEventStreamContext{info: unsafe.Pointer(&s.Chan)}

	var cstream C.FSEventStreamRef
	if dev == 0 {
		cstream = C.fswatch_create(&ctx, cpaths, csince, cinterval, cflags)
	} else {
		cdev := C.dev_t(dev)
		cstream = C.fswatch_create_relative_to_device(
			cdev, &ctx, cpaths, csince, cinterval, cflags)
	}
	s.cstream = cstream

	return s
}

// LatestEventID fetches the more recent EventID for the stream.
func (s Stream) LatestEventID() EventID {
	return EventID(C.FSEventStreamGetLatestEventId(s.cstream))
}

// Start schedules the stream on a new thread and begins delivering events on
// the channel.
func (s *Stream) Start() bool {
	type watchSuccessData struct {
		runloop C.CFRunLoopRef
		stream  Stream
	}

	successChan := make(chan C.CFRunLoopRef)

	go func() {
		C.FSEventStreamScheduleWithRunLoop(s.cstream,
			C.CFRunLoopGetCurrent(), C.kCFRunLoopCommonModes)
		ok := C.FSEventStreamStart(s.cstream) != C.FALSE
		if ok {
			successChan <- C.CFRunLoopGetCurrent()
			C.CFRunLoopRun()
		} else {
			successChan <- nil
		}
	}()

	runloop := <-successChan

	if runloop == nil {
		return false
	}
	s.runloop = runloop
	return true
}

// Flush any events that have not yet been delivered (synchronous).
func (s Stream) Flush() {
	C.FSEventStreamFlushSync(s.cstream)
}

// FlushAsync flushes any events that have not yet been delivered (asynchronous).
func (s Stream) FlushAsync() EventID {
	return EventID(C.FSEventStreamFlushAsync(s.cstream))
}

// Device is the device UUID supplied when the stream was created or 0.
func (s Stream) Device() Device {
	return Device(C.FSEventStreamGetDeviceBeingWatched(s.cstream))
}

// stop unregisters the FS Events service.
func (s Stream) stop() {
	C.FSEventStreamStop(s.cstream)
}

// invalidate the stream, unscheduling it from any run loops
func (s Stream) invalidate() {
	C.FSEventStreamInvalidate(s.cstream)
}

// release deallocates the stream and stops the run loop
func (s Stream) release() {
	C.FSEventStreamRelease(s.cstream)
	C.CFRunLoopStop(s.runloop)
}

// Close flushes, stops, invalidates and releases the stream.
func (s Stream) Close() {
	s.stop()
	s.invalidate()
	s.release()
}

// goCallback receives events from a stream.
//export goCallback
func goCallback(stream C.FSEventStreamRef, info unsafe.Pointer,
	count C.size_t, paths **C.char,
	flags *C.FSEventStreamEventFlags, ids *C.FSEventStreamEventId) {

	var events []Event
	for i := 0; i < int(count); i++ {
		cpaths := uintptr(unsafe.Pointer(paths)) + (uintptr(i) * unsafe.Sizeof(*paths))
		cpath := *(**C.char)(unsafe.Pointer(cpaths))

		cflags := uintptr(unsafe.Pointer(flags)) + (uintptr(i) * unsafe.Sizeof(*flags))
		cflag := *(*C.FSEventStreamEventFlags)(unsafe.Pointer(cflags))

		cids := uintptr(unsafe.Pointer(ids)) + (uintptr(i) * unsafe.Sizeof(*ids))
		cid := *(*C.FSEventStreamEventId)(unsafe.Pointer(cids))

		events = append(events, Event{
			ID:    EventID(cid),
			Path:  C.GoString(cpath),
			Flags: EventFlags(cflag),
		})
	}

	ch := *((*chan []Event)(info))
	ch <- events
}
